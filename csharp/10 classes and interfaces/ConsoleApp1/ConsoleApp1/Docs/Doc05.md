# Введение в классы и интерфейсы

## Интерфейсы

### Проблема множественного наследования

В классическом подходе ООП при наследовании больше чем от одного потомка сразу появляется серьёзная проблема выбора. Например:

```c#
class FavoriteChild : Tree, Cloud, Land
{}
```

Класс `FavoriteChild` настолько хорош, что хочет в себе сочетать свойства сразу трёх других объектов: `Tree`, `Cloud` и  `Land`

У каждого из этих трёх классов есть метод с одним и тем же названием: `Print()`, и конечно же `FavoriteChild` хочет его иметь, но не хочет реализовывать сам. Но каждый из трёх классов по-совему обрабатывает этот метод. Чья функция из трёх классов должна вызваться при вызове `FavoriteChild.Print()`? Первого или последнего класса? А может быть всех троих?

Кроме того, даже если принять определённое решение на уровне языка, например, что отработать должен метод `Print()` последнего класса, что делать, с ситуацией, если у `Cloud` и `Land` есть ещё один одинаковый метод `ToBe()`, а `FavoriteChild` хочет вызывать реализацию именно класса `Cloud`? А что делать, если `FavoriteChild` захочет добавить ещё класс `Hamburger`, который тоже имеет метод `Print()`?

### Решение

Интерфейсы как раз решают эту проблему. Он описывает, какие методы должен иметь класс, при этом никак не описывая как именно эти методы должны быть реализованы. Наследуемый интерфейс объект обязан сам решить что именно делать при запуске этого метода, но разработчик точно уверен, что этот метод вызывается так, и может объединять объекты с одинаковым поведением.
